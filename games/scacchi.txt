game "scacchi";

// movimenti
// cattura
// restrizione sul movimento del re
// situazione di scacco
// scacco matto

players 2;

tile sq
{

}

board
{
   tile[] 
   group square grid
   {
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
        sq,sq,sq,sq,sq,sq,sq,sq;
   } 
}

setup
{
   input board b;

   effect
   {
      player_state ps0 = player_state assign to player 0;

      player_state ps1 = player_state assign to player 1;
      ps1.pawn_direction = -1;

      // white player 0 board setup
      place new rook(owner = ps0) on b.group[0][7];
      // knight
      place new bishop(owner = ps0) on b.group[2][7];
      // queen
      place new king(owner = ps0) on b.group[4][7]
      place new bishop(owner = ps0) on b.group[5][7];
      // knight
      place new rook(owner = ps0) on b.group[7][7];
      
      // pawn line

      
      // black player 1 board setup
   }
}

local state player_state
{
   decimal pawn_direction = 1; // 1 is up -1 is down

   // ##### player pieces #####
   action move_piece
   {
      // TODO player trigger event
      input piece p 
      {
         return p.owner == this;
      };
      auto input piece[] enemy_pieces
      {
         filter piece ep
         {
            return ep.owner != this;
         }
      }
      auto input king k
      {
         return k.owner == this;
      }
      effect
      {
         // get all enemy pieces to check if king is in check and which pieces are checking
         bool in_check = false;
         decimal index = 0;
         tile[] enemy_vision = {};
         while(index < enemy_pieces.lenght)
         {
            enemy_vision.append(enemy_pieces[index]);
         }
         
         if(enemy_vision.contains(king.tile))
         {
            in_check = true;
         }

         // get current vision of selected piece 
         p.update_vision()
         vision[] vision = p.vision;
         
         // if the king is under check
         // TODO run the in check condition for all pieces if all fail no move can be made and it is checkmate

         // check if piece is pinned -> for every enemy piece check if king is in vision ( return piece as pinning ) 
         // if pinned and only one piece is pinning check if it can be taken ( overlap pinning vision with piece vision )
         // valid move ( king is not in check after the mvoe ):
         //    save previous position
         //    check for each tile in this.vision 
         //    move piece and compute in_check vision
         //    if in_check is true position remove tile from vision
         //    restore original piece position

         // if there's no possibile move -> stop action
         if(vision.lenght == 0)
         {
            fail;
         }

         // select move
         input tile dest 
         {
            return vision.contains(dest);
         }
         
         // if destination has enemy piece ( placeables in it ) capture it 
         if(dest.placeables.lenght > 1)
         {
            dest.placeables.clear();
         }
         
         move p to dest;
      }
   }
}

interactable piece placeable
{
   player_state owner = none;
   tile[] vision = {};

   action compute_vision 
   {
      effect { }
   }
}

interactable rook : piece
{
   override action compute_vision
   {
      override effect
      {
         this.vision.clear();
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: 0));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: 0));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 0, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 0, y: -1));
      }
   }
}

interactable bishop : piece 
{
   override action compute_vision
   {
      override effect
      {
         this.vision.clear();
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: -1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: -1));
      }
   }
}

interactable king : piece 
{
   override action compute_vision
   {
      auto input piece[] enemy_pieces 
      {
         filter piece p
         {
            return p.owner != this.owner;
         }
      }
      override effect 
      {
         group g = this.tile.group; 
         decimal x = this.tile.x;
         decimal y = this.tile.y;
         
         this.vision.clear();
         if(check_vision_tile(t: g[x - 1][y - 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 1][y - 1]; }
         if(check_vision_tile(t: g[x - 1][y - 0], this.owner)) { this.vision[this.vision.lenght] = g[x - 1][y - 0]; }
         if(check_vision_tile(t: g[x - 1][y + 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 1][y + 1]; }
         if(check_vision_tile(t: g[x - 0][y - 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 0][y - 1]; }
         if(check_vision_tile(t: g[x - 0][y + 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 0][y + 1]; }
         if(check_vision_tile(t: g[x + 1][y - 1], this.owner)) { this.vision[this.vision.lenght] = g[x + 1][y - 1]; }
         if(check_vision_tile(t: g[x + 1][y - 0], this.owner)) { this.vision[this.vision.lenght] = g[x + 1][y - 0]; }
         if(check_vision_tile(t: g[x + 1][y + 1], this.owner)) { this.vision[this.vision.lenght] = g[x + 1][y + 1]; }

         decimal index = 0;
         while(index < enemy_pieces.lenght)
         {
            piece ep = enemy_piece[index];
            ep.compute_vision();
            this.vision = this.vision.removeRange(ep.vision);

            index += 1;
         }
      }
   }
}

interactable queen : piece
{
   override action compute_vision
   {
      override effect
      {
         this.vision.clear();
         // bishop movement
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: -1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: -1));
         // rook movement
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 1, y: 0));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: -1, y: 0));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 0, y: 1));
         this.vision.append(line_till_obstruction(tile: this.tile, moving: this.owner, x: 0, y: -1));
      }
   }
}

interactable knight: piece
{
   override action compute_vision
   {
      override effect
      {
         group g = this.tile.group; 
         decimal x = this.tile.x;
         decimal y = this.tile.y;
         
         this.vision.clear();
         if(check_vision_tile(t: g[x - 1][y - 2], this.owner)) { this.vision[this.vision.lenght] = g[x - 1][y - 2]; }
         if(check_vision_tile(t: g[x + 1][y - 2], this.owner)) { this.vision[this.vision.lenght] = g[x + 1][y - 2]; }
         if(check_vision_tile(t: g[x - 1][y + 2], this.owner)) { this.vision[this.vision.lenght] = g[x - 1][y + 2]; }
         if(check_vision_tile(t: g[x + 1][y + 2], this.owner)) { this.vision[this.vision.lenght] = g[x + 1][y + 2]; }
         if(check_vision_tile(t: g[x + 2][y + 1], this.owner)) { this.vision[this.vision.lenght] = g[x + 2][y + 1]; }
         if(check_vision_tile(t: g[x + 2][y - 1], this.owner)) { this.vision[this.vision.lenght] = g[x + 2][y - 1]; }
         if(check_vision_tile(t: g[x - 2][y + 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 2][y + 1]; }
         if(check_vision_tile(t: g[x - 2][y - 1], this.owner)) { this.vision[this.vision.lenght] = g[x - 2][y - 1]; }
      }
   }
}

interactable pawn: piece
{
   override action compute_vision
   {
      override effect
      {
         group g = this.tile.group;
         decimal x = this.tile.x;
         decimal y - this.tile.y;
         decimal direction = 1 * this.owner.pawn_direction;

         this.vision.clear();

         // if front is clear add 
         tile front = g[x][y - direction];
         if(front.placeables.lenght == 0)
         {
            this.vision[this.vision.lenght] = front;
         }

         // add up left if there is an enemy piece
         tile left = g[x - 1][y - direction];
         if(left.placeables.lenght > 0 && (left.placeables[0] as piece).owner != this.owner)
         {
            this.vision[this.vision.lenght] = front;
         }

         // add up right if there is an enemy piece
         tile right = g[x + 1][y - direction];
         if(right.placeables.lenght > 0 && (right.placeables[0] as piece).owner != this.owner)
         {
            this.vision[this.vision.lenght] = front;
         }
      }
   }
}

// ##### HELPER VERBS ######

verb line_till_obstruction
{
   verb input tile src;
   verb input player_state moving;
   verb input decimal x;
   verb input decimal y;
   effect
   {
      group g = src.group;
      tile c = g[src.x + x][src.y + y];
      tile[] line = {};
      while(c != none && c.placeables.lenght == 0){
         line.add(c);
         c = g[c.x + x][c.y + y];
      }

      if(check_vision_tile(t: c, owner: moving))
      {
         line.add(c);
      }

      return line; 
   }
}

verb check_vision_tile 
{
   verb input tile t;
   verb input player_state owner;

   effect
   {
      if(t == null)
         return false;

      if(t.placeables.lenght > 0)
      {
         piece p = t.placeables[0] as piece;
         return p.owner != owner;
      }
      return true;
   }
}